
<style>
textarea {
    width: 500px;
    min-height: 75px;
}
</style>

<div id="container">
  <div id="remotePeers"></div>
  <video id="localVideo" playsinline autoplay muted></video>
  <div class="box">
    <span>name<input type="text" name="Name" id="name"/></span>
    <span>room<input type="text" name="Room" id="room" value="r1"/></span>
    <button id="startButton">Join</button>
    <button id="hangupButton">Hang Up</button>
  </div>

  <div id="chatbox"></div>

</div>


<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script>

const startButton = document.getElementById('startButton');
const hangupButton = document.getElementById('hangupButton');

hangupButton.disabled = true;

const remoteVideos = document.getElementById('remotePeers');
const localVideo = document.getElementById('localVideo');

const nameInput = document.getElementById('name');
const roomInput = document.getElementById('room');

let peers = {};
let peerOffers = {};
let name;
let offer;
let localStream;
let ws;

signal = (recipient, msg) => {
  console.log(`sending message to ${recipient}: ${JSON.stringify(msg)}`);
  ws.send(JSON.stringify({"recipient": recipient, "payload": msg}));
};

startButton.onclick = async () => {
  localStream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
  localVideo.srcObject = localStream;

  startButton.disabled = true;
  hangupButton.disabled = false;

  name = nameInput.value;
  let roomCode = roomInput.value;
  nameInput.disabled = true;
  roomInput.disabled = true;

  ws = new WebSocket(`wss://meet.verrdon.com/ws/${roomCode}/${name}`);

  // ws = new WebSocket(`wss://localhost:7878/ws/${roomCode}/${name}`);
  await waitForOpen();
  signal(name, {"echo": {"message": "hello"}});
  ws.onmessage = async (event) => {
    console.log(event);
    let text = event;
    try {
      console.log(`Received: ${event.data}`);
      const msg = JSON.parse(event.data);
      let payload = msg.payload;
      if (payload.peers) {
        payload.peers.names.forEach(async (peerName) => {
          var pc = await createPeerConnection(peerName);
          offer = await pc.createOffer();
          // peerOffers[peerName] = offer;
          await pc.setLocalDescription(offer);
          signal(peerName, {"offer":{"sender":name, "payload": btoa(JSON.stringify(offer))}});
        });

      } else if (payload.offer) {
        let rdJson = atob(payload.offer.payload);
        // console.log(`received remote description ${rdJson}`);

        var pc = await createPeerConnection(payload.offer.sender);
        await pc.setRemoteDescription(JSON.parse(rdJson));
        let answer = await pc.createAnswer();
        console.log(`sending answer to ${payload.offer.sender}: ${JSON.stringify(answer)}`);
        signal(payload.offer.sender, {"answer":{"sender":name, "payload": btoa(JSON.stringify(answer))}});
        await pc.setLocalDescription(answer);
      } else if(payload.answer) {
        var peerName = payload.answer.sender;
        await peers[peerName].setRemoteDescription(JSON.parse(atob(payload.answer.payload)));
        // await pc.setLocalDescription(peerOffers[peerName]);
      } else if(payload.candidate) {
        var pc = peers[payload.candidate.sender];
        if (!pc) {
          // console.error('no peerconnection');
          return;
        }
        // DANGER, probably. We can queue these on the server
        // or at least cap the wait before we get the answer
        while(!pc.remoteDescription) {
          await new Promise(r => setTimeout(r, 100));
          pc = peers[payload.candidate.sender];
        }
        
        await pc.addIceCandidate(JSON.parse(atob(payload.candidate.payload)));
      }
    } catch (e) {
      console.log("failed to parse event data: ", e);
    }
  };
};

hangupButton.onclick = async () => {
  hangup();
};

async function hangup() {
  Object.entries(peers).forEach((n, pc) => {
    if (pc) {
      pc.close();
      pc = null;
    }
    let removeVideo = document.getElementById('remoteVideo' + n);
    if (removeVideo) {
      removeVideo.remove();
    }
    // remoteVideos.removeChild(removeVideo);
  });
  
  startButton.disabled = false;
  hangupButton.disabled = true;
  nameInput.disabled = false;
  roomInput.disabled = false;
  localStream.getTracks().forEach(track => track.stop());
  localStream = null;
  if (ws) {
    ws.close();
  }
};

async function createPeerConnection(peerName) {
  console.log(`creating peer connection with ${peerName}`);
  // pc = new RTCPeerConnection();
  var pc = new RTCPeerConnection({
    iceServers: [
      {
        urls: 'turn:meet.verrdon.com:3478',
        username: "barfolomew",
        credential: "thatsgoingtoleaveamark"
      },
      {
        urls: 'stun:stun.l.google.com:19302'
      }
    ]});
  pc.onicecandidate = async e => {
    if (e.candidate) {
      if (!(ws && ws.readyState == WebSocket.OPEN)) {
        await waitForOpen();
      }
      signal(peerName, {"candidate": {"sender": name, "payload": btoa(JSON.stringify(e.candidate))}});
    }
  };

  var videoElement = document.createElement('video');
  videoElement.id = 'remoteVideo' + peerName;
  videoElement.playsInline = true;
  videoElement.autoplay = true;
  remoteVideos.appendChild(videoElement);

  pc.ontrack = e => videoElement.srcObject = e.streams[0];
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  peers[peerName] = pc;
  return pc;
}

async function waitForOpen() {
  while(!(ws && ws.readyState == WebSocket.OPEN)) {
    console.log(`waiting for WebSocket.OPEN`);
    await new Promise(r => setTimeout(r, 1000));
  }
}

</script>
