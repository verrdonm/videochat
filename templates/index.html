
<style>
textarea {
    width: 500px;
    min-height: 75px;
}
</style>

<div id="container">
  <div id="remotePeers"></div>
  <video id="localVideo" playsinline autoplay muted style="transform: scale(-1, 1); -webkit-transform: scale(-1, 1);"></video>
  <div class="box">
    <span>name<input type="text" name="Name" id="name"/></span>
    <span>room<input type="text" name="Room" id="room" value="r1"/></span>
    <button id="startButton">Join</button>
    <button id="muteButton">Mute</button>
    <button id="hangupButton">Hang Up</button>
  </div>

  <div id="chatbox"></div>

</div>


<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script>

const IceStats = class {
  constructor() {
    this.sent = 0;
    this.received = 0;
  }

  incSent() {
    this.sent++;
  }

  incReceived() {
    this.received++;
  }
}

const Peer = class {
  constructor(name, pc, ice) {
    this.name = name;
    this.pc = pc;
    this.ice = ice;
  }
}

const startButton = document.getElementById('startButton');
const hangupButton = document.getElementById('hangupButton');
const muteButton = document.getElementById('muteButton');

hangupButton.disabled = true;

const remoteVideos = document.getElementById('remotePeers');
const localVideo = document.getElementById('localVideo');

const nameInput = document.getElementById('name');
const roomInput = document.getElementById('room');

let peers = {};
let name;
let offer;
let localStream;
let ws;

signal = (recipient, msg) => {
  console.log(`sending message to ${recipient}: ${JSON.stringify(msg)}`);
  ws.send(JSON.stringify({"recipient": recipient, "payload": msg}));
};

startButton.onclick = async () => {
  localStream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
  localVideo.srcObject = localStream;

  startButton.disabled = true;
  hangupButton.disabled = false;

  name = nameInput.value;
  let roomCode = roomInput.value;
  nameInput.disabled = true;
  roomInput.disabled = true;

  ws = new WebSocket(`wss://meet.verrdon.com/ws/${roomCode}/${name}`);

  // ws = new WebSocket(`wss://localhost:7878/ws/${roomCode}/${name}`);
  await waitForOpen();
  signal(name, {"echo": {"message": "hello"}});
  ws.onmessage = async (event) => {
    let text = event;
    try {
      console.log(`Received: ${event.data}`);
      const msg = JSON.parse(event.data);
      let payload = msg.payload;
      if (payload.peers) {
        payload.peers.names.forEach(async (peerName) => {
          if (peers[peerName]) return;
          var pc = await createPeerConnection(peerName);
          offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          signal(peerName, {"offer":{"sender":name, "payload": btoa(JSON.stringify(offer))}});
        });
      } else if (payload.offer) {
        if (peers[payload.offer.sender]) {return;}

        var pc = await createPeerConnection(payload.offer.sender);
        await pc.setRemoteDescription(JSON.parse(atob(payload.offer.payload)));
        let answer = await pc.createAnswer();
        signal(payload.offer.sender, {"answer":{"sender":name, "payload": btoa(JSON.stringify(answer))}});
        await pc.setLocalDescription(answer);
      } else if(payload.answer) {
        var peerName = payload.answer.sender;
        await peers[peerName].pc.setRemoteDescription(JSON.parse(atob(payload.answer.payload)));
      } else if(payload.candidate) {
        var peer = peers[payload.candidate.sender];
        var pc = peer.pc;
        if (!pc) {
          return;
        }
        while(!pc.remoteDescription) {
          await new Promise(r => setTimeout(r, 100))
        }
        await pc.addIceCandidate(JSON.parse(atob(payload.candidate.payload)));
        peer.ice.incReceived();
      }
    } catch (e) {
      console.log("failed to parse event data: ", e);
    }
  };
};

hangupButton.onclick = async () => {
  hangup();
};

async function hangup() {
  Object.entries(peers).forEach((n, peer) => {
    console.log(`hanging up ${n} connection ${peer}`);
    if (peer && peer.pc) {
      var pc = peer.pc;
      pc.getSenders().forEach((sender) => {
        sender.track.stop();
      });
      pc.close();
      pc = null;
    }
    let v = document.getElementById('remoteVideo' + n);
    if (v) {
      v.remove();
    }
    // remoteVideos.removeChild(removeVideo);
  });
  peers = {};
  remoteVideos.innerHTML="";
  startButton.disabled = false;
  hangupButton.disabled = true;
  nameInput.disabled = false;
  roomInput.disabled = false;
  localStream.getTracks().forEach(track => track.stop());
  localStream = null;
  if (ws) {
    ws.close();
  }
};

async function createPeerConnection(peerName) {
  console.log(`creating peer connection with ${peerName}`);
  // pc = new RTCPeerConnection();
  var pc = new RTCPeerConnection({
    iceServers: [
      {
        urls: 'turn:meet.verrdon.com:3478',
        username: "barfolomew",
        credential: "thatsgoingtoleaveamark"
      },
      {
        urls: 'stun:stun.l.google.com:19302'
      }
    ]});
  var peer = new Peer(peerName, pc, new IceStats());

  pc.onicecandidate = async e => {

    console.log(`onicecandidate e: ${JSON.stringify()}`);
    if (e.candidate) {
      await waitForOpen();
      console.log(JSON.stringify(pc));
      while(!pc.remoteDescription) {
        console.log(`waiting for remote description in onicecandidate: ${pc.remoteDescription}`);
        await new Promise(r => setTimeout(r, 400));
      }
      signal(peer.name, {"candidate": {"sender": name, "payload": btoa(JSON.stringify(e.candidate))}});
      peer.ice.incSent();
    }
  };
  var videoElementId = 'remoteVideo' + peerName;
  var videoElement = document.getElementById(videoElementId);

  if (!videoElement) {
    var videoElement = document.createElement('video');
    videoElement.id = 'remoteVideo' + peerName;
    videoElement.playsInline = true;
    videoElement.autoplay = true;
    remoteVideos.appendChild(videoElement);
  }

  pc.ontrack = e => {
    console.log(`on track: ${JSON.stringify(e)}`);
    videoElement.srcObject = e.streams[0];
  };

  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  peers[peerName] = peer;
  return pc;
}

async function waitForOpen() {
  while(!(ws && ws.readyState == WebSocket.OPEN)) {
    console.log(`waiting for WebSocket.OPEN`);
    await new Promise(r => setTimeout(r, 200));
  }
}

muteButton.onclick = () => mute();

function mute() {
  muteButton.innerText = localStream.getAudioTracks()[0].enabled ? "Unmute" : "Mute";
  localStream.getAudioTracks()[0].enabled=!localStream.getAudioTracks()[0].enabled;
}
</script>
