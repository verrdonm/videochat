
<style>
textarea {
    width: 500px;
    min-height: 75px;
}
</style>

<div id="container">
  <div id="remotePeers"></div>
  <video id="localVideo" playsinline autoplay muted></video>
  <div class="box">
    <span>name<input type="text" name="Name" id="name"/></span>
    <span>room<input type="text" name="Room" id="room" value="r1"/></span>
    <button id="startButton">Join</button>
    <button id="hangupButton">Hang Up</button>

    <button id="forceOffer">Offer</button>
  </div>

  <div id="chatbox"></div>

</div>


<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script>

const startButton = document.getElementById('startButton');
const hangupButton = document.getElementById('hangupButton');

hangupButton.disabled = true;

const remoteVideos = document.getElementById('remotePeers');
const localVideo = document.getElementById('localVideo');

const nameInput = document.getElementById('name');
const roomInput = document.getElementById('room');

let peers = {};
let name;
let offer;
let localStream;
let ws;

signal = (recipient, msg) => {
  ws.send(JSON.stringify({"recipient": recipient, msg}));
};

startButton.onclick = async () => {
  localStream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
  localVideo.srcObject = localStream;

  startButton.disabled = true;
  hangupButton.disabled = false;

  name = nameInput.value;
  let roomCode = roomInput.value;
  nameInput.disabled = true;
  roomInput.disabled = true;

  ws = new WebSocket(`wss://meet.verrdon.com/ws/${roomCode}/${name}`);

  // ws = new WebSocket(`wss://localhost:7878/ws/${roomCode}/${name}`);
  while(ws.readyState != WebSocket.OPEN) {
    await new Promise(r => setTimeout(r, 1000));
  }
  ws.onmessage = async (event) => {
    console.log(event);
    let text = event;
    try {
      const msg = JSON.parse(event.data);

      if (msg.peers) {
        msg.peers.names.forEach(async (name) => {
          var pc = await createPeerConnection(name);
          offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          signal(name, {"offer":{"sender":name, "payload": btoa(JSON.stringify(offer))}});
        });

      } else if (msg.offer) {
        let rdJson = atob(msg.offer.payload);
        // console.log(`received remote description ${rdJson}`);

        var pc = await createPeerConnection(msg.offer.sender);
        await pc.setRemoteDescription(JSON.parse(rdJson));
        let answer = await pc.createAnswer();
        console.log(`sending answer to ${msg.offer.name}: ${JSON.stringify(answer)}`);
        signal(msg.offer.sender, {"answer":{"sender":name, "payload": btoa(JSON.stringify(answer))}});
        await pc.setLocalDescription(answer);
      } else if(msg.answer) {
        await peers[msg.answer.sender].setRemoteDescription(JSON.parse(atob(msg.answer.sdp)));
      } else if(msg.candidate) {
        var pc = peers[msg.candidate.sender];
        if (!pc) {
          // console.error('no peerconnection');
          return;
        }
        // DANGER, probably. We can queue these on the server
        // or at least cap the wait before we get the answer
        while(!pc.remoteDescription) {
          await new Promise(r => setTimeout(r, 100));
          pc = peers[msg.candidate.sender];
        }
        
        await pc.addIceCandidate(JSON.parse(atob(msg.candidate.payload)));
      }
    } catch (e) {
      console.log("failed to parse event data: ", e);
    }
  };
};

hangupButton.onclick = async () => {
  hangup();
};

async function hangup() {
  if (pc) {
    pc.close();
    pc = null;
  }
  localStream.getTracks().forEach(track => track.stop());
  localStream = null;
  startButton.disabled = false;
  hangupButton.disabled = true;
  nameInput.disabled = false;
  roomInput.disabled = false;

  if (ws) {
    ws.close();
  }
};

async function createPeerConnection(peerName) {
  // pc = new RTCPeerConnection();
  var pc = new RTCPeerConnection({
    iceServers: [
      {
        urls: 'turn:meet.verrdon.com:3478',
        username: "barfolomew",
        credential: "thatsgoingtoleaveamark"
      },
      {
        urls: 'stun:stun.l.google.com:19302'
      }
    ]});
  pc.onicecandidate = async e => {
    if (e.candidate) {
      const message = {
        sender_name: name,
        candidate: btoa(JSON.stringify(e.candidate)),
      };
      if (!(ws && ws.readyState == WebSocket.OPEN)) {
        while(!(ws && ws.readyState == WebSocket.OPEN)) {
          await new Promise(r => setTimeout(r, 1000));
        }
      }
      if (ws && ws.readyState == WebSocket.OPEN) {
        console.log(`sending candidate info ${stringMsg}`);
        signal(peerName, {"sender": name, "payload": btoa(JSON.stringify(e.candidate))});
      }
    }
  };


  var videoElement = document.createElement('remoteVideo' + peerName);
  videoElement.playsInline = true;
  videoElement.autoplay = true;
  remoteVideos.appendChild(videoElement);

  pc.ontrack = e => videoElement.srcObject = e.streams[0];
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  peers[name] = pc;
  return pc;
}

</script>
